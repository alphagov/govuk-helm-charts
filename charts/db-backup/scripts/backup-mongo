#!/bin/bash
set -euo pipefail

source_dir=$(dirname "${BASH_SOURCE[0]}")
. "$source_dir/lib.sh"

db_url="${DB_MONGO_CONNECTION_STRING%/}/$DB_DATABASE"

backup () {
  local s3_path
  s3_path="$DB_HOST/$(date -u +%Y-%m-%dT%H%M%SZ)-$DB_DATABASE.gz"
  local s3_url="$BUCKET/$s3_path"

  mongodump "$db_url" --archive \
    | progress | gzip -1 | s5cmd pipe "$s3_url" \
    && write_pointer "${s3_path}"

  get_object_size "$s3_url"
}

dump_is_readable () {
  # We expect the piped series to fail with error code 141 sometimes,
  # this is because we cut off the stdout of s5cmd when it's only cat-ted
  # part of the file, so it gets a SIGPIPE, which bubbbles up through the pipefail
  #
  # So we should check every return code in the PIPESTATUS array (an array of the
  # return codes of every command in the pipe) and ignore any that were 141 SIGPIPE
  if ! s5cmd cat -c 1 -p 1 "$1" | gzip -d | head -c 100 | grep -q concurrent_collections; then
    for EXIT_CODE in "${PIPESTATUS[@]}"; do
      if [[ "$EXIT_CODE" -ne 0 ]] && [[ "$EXIT_CODE" -ne 141 ]]; then
        # We got an exit code from a command which wasn't SIGPIPE
        # so return it as a failure exit code
        return "$EXIT_CODE"
      fi
    done
  fi
}

restore () {
  if [[ "$GOVUK_ENVIRONMENT" = *"prod"* ]]; then
    : "${REALLY_RESTORE_ONTO_PRODUCTION?}"
  fi
  local s3_url
  s3_url="$(object_uri)"
  dump_is_readable "$s3_url"

  get_object_size "$s3_url"

  s5cmd cat -c 1 "$s3_url" | gzip -d | mongorestore "$db_url" --archive --drop -j 1
}

transform () {
  shift
  (cd "$source_dir" && mongosh --quiet "$db_url" < "$1")
}

subcommand=${1:-}
[[ $(type -t "$subcommand") == function ]] || usage

send_prometheus_metric "mongo" "${subcommand}" "started"
trap 'send_prometheus_terminal_metric mongo "$subcommand"' EXIT

$subcommand "$@"

echo "done"
