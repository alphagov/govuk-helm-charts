#!/bin/bash
set -euo pipefail

source_dir=$(dirname "${BASH_SOURCE[0]}")
. "$source_dir/lib.sh"

export PGUSER=$DB_USER
export PGPASSWORD=$DB_PASSWORD
export PGHOST=$DB_HOST
export PGDATABASE=postgres

backup () {
  local s3_path
  s3_path="$DB_HOST/$(date -u +%Y-%m-%dT%H%M%SZ)-$DB_DATABASE.gz"
  local s3_url="$BUCKET/$s3_path"

  PGDATABASE=$DB_DATABASE \
    pg_dump -Fc -Z1 | progress | s5cmd pipe "$s3_url" \
    && write_pointer "${s3_path}"

  get_object_size "$s3_url"
}

transform () {
  shift
  (cd "$source_dir" && psql "$DB_DATABASE" < "$1")
}

dump_is_readable () {
  # We expect the piped series to fail with error code 141 sometimes,
  # this is because we cut off the stdout of s5cmd when it's only cat-ted
  # part of the file, so it gets a SIGPIPE, which bubbbles up through the pipefail
  #
  # So we should check every return code in the PIPESTATUS array (an array of the
  # return codes of every command in the pipe) and ignore any that were 141 SIGPIPE
  if ! s5cmd cat -c 1 -p 1 "$1" | head | file - | tee /dev/fd/2 \
      | grep -iq 'PostgreSQL custom database dump'; then

    for EXIT_CODE in "${PIPESTATUS[@]}"; do
      if [[ "$EXIT_CODE" -ne 0 ]] && [[ "$EXIT_CODE" -ne 141 ]]; then
        # We got an exit code from a command which wasn't SIGPIPE
        # so return it as a failure exit code
        return "$EXIT_CODE"
      fi
    done
  fi
}

db_exists () {
  psql -Alqt | grep -Eo '^[^|]+\|' | grep -Fq "$1|"
}

rename_db () {
  psql -v ON_ERROR_STOP=1 <<EOF
BEGIN;
SELECT pg_terminate_backend(pid) FROM pg_stat_activity
WHERE pid <> pg_backend_pid() AND usename <> 'rdsadmin' AND datname = '$1';
ALTER DATABASE "$1" OWNER TO session_user;
ALTER DATABASE "$1" RENAME TO "$2";
COMMIT;
EOF
}

swap_dbs () {
  local RETRY_COUNT=0
  local MAX_RETRIES=10
  local SLEEP_SECONDS_BETWEEN_RETRIES=5
  local TERMINATION_TIMEOUT_MILLISECONDS=10000

  local INCOMING_DB_NAME="$1"
  local DB_NAME="$2"
  local OUTGOING_DB_NAME="$2"

  # We will do the session termination between each command to give maximum chance all clients are not
  # connected
  QUERY=$(cat <<EOF
  BEGIN;

  ALTER DATABASE "$DB_NAME" OWNER TO session_user;

  SELECT pg_terminate_backend(pid, $TERMINATION_TIMEOUT_MILLISECONDS) FROM pg_stat_activity
  WHERE pid <> pg_backend_pid() AND usename <> 'rdsadmin'
    AND datname = '$DB_NAME';

  ALTER DATABASE "$DB_NAME" RENAME TO "$OUTGOING_DB_NAME";

  SELECT pg_terminate_backend(pid, $TERMINATION_TIMEOUT_MILLISECONDS) FROM pg_stat_activity
  WHERE pid <> pg_backend_pid() AND usename <> 'rdsadmin'
    AND datname = '$INCOMING_DB_NAME';

  ALTER DATABASE "$INCOMING_DB_NAME" RENAME TO "$DB_NAME";
  COMMIT;
EOF
  )

  echo "Disabling new connections to $DB_NAME" >&2
  psql --command "ALTER DATABASE \"$DB_NAME\" WITH OPTION ALLOW_CONNECTIONS false;"

  while [ "$RETRY_COUNT" -lt "$MAX_RETRIES" ]; do
    if psql --set ON_ERROR_STOP=1 <<<"$QUERY"; then
      echo "Database swap successful" >&2

      echo "Enabling new connections to $OUTGOING_DB_NAME"
      psql --command "ALTER DATABASE \"$OUTGOING_DB_NAME\" WITH OPTION ALLOW_CONNECTIONS true;"

      return 0
    fi

    RETRY_COUNT=$((RETRY_COUNT + 1))
    echo "Database swap failed, sleeping for $SLEEP_SECONDS_BETWEEN_RETRIES seconds before trying again" >&2
    sleep "$SLEEP_SECONDS_BETWEEN_RETRIES"
  done

  echo "Terminal Error: Database swap failed after $MAX_RETRIES retries!" >&2

  echo "Re-enabling new connections to $DB_NAME" >&2
  psql --command "ALTER DATABASE \"$DB_NAME\" WITH OPTION ALLOW_CONNECTIONS true;"

  return 1
}

restore () {
  if [[ "$GOVUK_ENVIRONMENT" = *"prod"* ]]; then
    : "${REALLY_RESTORE_ONTO_PRODUCTION?}"
  fi
  local s3_url
  s3_url="$(object_uri)"
  dump_is_readable "$s3_url"

  get_object_size "$s3_url"

  dropdb -ef --if-exists "$DB_DATABASE-restore"
  createdb -eT template0 "$DB_DATABASE-restore"
  s5cmd cat -c 1 "$s3_url" | progress | pg_restore --no-comments -f - \
    | psql -d "$DB_DATABASE-restore" -c "SET session_replication_role = 'replica';" -f -

  if db_exists "$DB_DATABASE"; then
    dropdb -ef --if-exists "$DB_DATABASE-old"
    swap_dbs "$DB_DATABASE-restore" "$DB_DATABASE" "$DB_DATABASE-old"
  else
    rename_db "$DB_DATABASE-restore" "$DB_DATABASE"
  fi
  psql -c "ALTER DATABASE \"$DB_DATABASE\" OWNER TO \"$DB_OWNER\";"

  dropdb -ef --if-exists "$DB_DATABASE-old"
}

subcommand=${1:-}
[[ $(type -t "$subcommand") == function ]] || usage

send_prometheus_metric "postgres" "${subcommand}" "started"

[[ "${VERBOSE:-0}" -ge 1 ]] && set -x

trap 'send_prometheus_terminal_metric postgres "$subcommand"' EXIT

$subcommand "$@"

echo "done"
