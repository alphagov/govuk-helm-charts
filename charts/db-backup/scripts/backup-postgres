#!/bin/bash
set -euo pipefail

source_dir=$(dirname "${BASH_SOURCE[0]}")
. "$source_dir/lib.sh"

export PGUSER=$DB_USER
export PGPASSWORD=$DB_PASSWORD
export PGHOST=$DB_HOST
export PGDATABASE=postgres

backup () {
  local s3_path
  s3_path="$DB_HOST/$(date -u +%Y-%m-%dT%H%M%SZ)-$DB_DATABASE.gz"
  PGDATABASE=$DB_DATABASE \
    pg_dump -Fc -Z1 | progress | aws s3 cp - "$BUCKET/$s3_path"
}

transform () {
  shift
  (cd "$source_dir" && psql < "$1")
}

dump_is_readable () {
  (aws s3 cp "$s3_url" - 2>/dev/null || true) | head | file - | tee /dev/fd/2 \
    | grep -iq 'PostgreSQL custom database dump'
}

db_exists () {
  psql -Alqt |grep -Eo '^\w+\|' |grep -Fq "$1|"
}

rename_db () {
  psql -1 <<EOF
SELECT pg_terminate_backend(pid) FROM pg_stat_activity
WHERE pid <> pg_backend_pid() AND datname='$1';
ALTER DATABASE "$1" OWNER TO session_user;
ALTER DATABASE "$1" RENAME TO "$2";
EOF
}

swap_dbs () {
  psql -1 <<EOF
SELECT pg_terminate_backend(pid) FROM pg_stat_activity
WHERE pid <> pg_backend_pid() AND datname IN ('$1', '$2');
ALTER DATABASE "$2" OWNER TO session_user;
ALTER DATABASE "$2" RENAME TO "$3";
ALTER DATABASE "$1" RENAME TO "$2";
EOF
}

restore () {
  : "${FILENAME:=$(list | tail -1)}"  # Use latest dump if not specified.
  if [[ "$GOVUK_ENVIRONMENT" = *"prod"* ]]; then
    : "${REALLY_RESTORE_ONTO_PRODUCTION?}"
  fi
  local s3_url="$BUCKET/$DB_HOST/$FILENAME"
  s3_url="$s3_url" dump_is_readable

  dropdb -ef --if-exists "$DB_DATABASE-restore"
  createdb -eT template0 "$DB_DATABASE-restore"
  aws s3 cp "$s3_url" - | progress | pg_restore -d "$DB_DATABASE-restore" --no-comments

  if db_exists "$DB_DATABASE"; then
    dropdb -ef --if-exists "$DB_DATABASE-old"
    swap_dbs "$DB_DATABASE-restore" "$DB_DATABASE" "$DB_DATABASE-old"
  else
    rename_db "$DB_DATABASE-restore" "$DB_DATABASE"
  fi
  psql -c "ALTER DATABASE \"$DB_DATABASE\" OWNER TO \"$DB_OWNER\";" || true

  dropdb -ef --if-exists "$DB_DATABASE-old"
}

subcommand=${1:-}
[[ $(type -t "$subcommand") == function ]] || usage

[[ "${VERBOSE:-0}" -ge 1 ]] && set -x
$subcommand "$@"
echo "done"
