apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-nginx-conf
  labels:
    {{- include "asset-manager.labels" . | nindent 4 }}
    app.kubernetes.io/component: web
data:
  nginx.conf: |-
    user nginx;

    error_log /dev/stderr warn;
    pid /tmp/nginx.pid;

    load_module /usr/lib/nginx/modules/ngx_http_perl_module.so;

    events {
      worker_connections 1024;
    }

    http {
      upstream {{ .Release.Name }} {
        server 127.0.0.1:{{ .Values.appPort }};
      }

      # This map creates a $sts_default variable for later use.
      # If this header is already set by upstream, then $sts_default will
      # be an empty string, which will later lead to:
      #    add_header Strict-Transport-Security ''
      # which will be ignored according to http://serverfault.com/a/598106
      # If the header is not set by upstream, then $sts_default will be set
      # and later uses in add_header will be effective.
      map $upstream_http_strict_transport_security $sts_default {
        '' "max-age=31536000; preload";
      }

      log_format timed_combined '$remote_addr - $remote_user [$time_local]  '
        '"$request" $status $body_bytes_sent '
        '"$http_referer" "$http_user_agent" '
        '$request_time $upstream_response_time '
        '$gzip_ratio $sent_http_x_cache $sent_http_location $http_host '
        '$ssl_protocol $ssl_cipher '
        '$http_x_forwarded_for';
    
      log_format json_event '{ "@timestamp": "$time_iso8601", '
                           '"remote_addr": "$remote_addr", '
                           '"remote_user": "$remote_user", '
                           '"body_bytes_sent": $body_bytes_sent, '
                           '"bytes_sent": $bytes_sent, '
                           '"request_time": $request_time, '
                           '"upstream_response_time": "$upstream_response_time", '
                           '"upstream_addr": "$upstream_addr", '
                           '"gzip_ratio": "$gzip_ratio", '
                           '"sent_http_x_cache": "$sent_http_x_cache", '
                           '"sent_http_location": "$sent_http_location", '
                           '"sent_http_content_type": "$sent_http_content_type", '
                           '"http_host": "$http_host", '
                           '"server_name": "$server_name", '
                           '"server_port": "$server_port", '
                           '"status": $status, '
                           '"request": "$request", '
                           '"request_method": "$request_method", '
                           '"http_referrer": "$http_referer", '
                           '"http_user_agent": "$http_user_agent", '
                           '"govuk_request_id": "$http_govuk_request_id", '
                           '"govuk_original_url": "$http_govuk_original_url", '
                           '"govuk_dependency_resolution_source_content_id": "$http_govuk_dependency_resolution_source_content_id", '
                           '"varnish_id": "$http_x_varnish", '
                           '"ssl_protocol": "$ssl_protocol", '
                           '"ssl_cipher": "$ssl_cipher", '
                           '"http_x_forwarded_for": "$http_x_forwarded_for" }';

      # Set GOVUK-Request-Id if not set
      # See http://nginx.org/en/docs/http/ngx_http_perl_module.html
      perl_modules perl/lib;
      perl_set $govuk_request_id '
        sub {
          my $r = shift;
          my $current_header = $r->header_in("GOVUK-Request-Id");

          if (defined $current_header && $current_header ne "") {
            return $current_header;
          } else {
            my $pid = $r->variable("pid");
            my $msec = $r->variable("msec");
            my $remote_addr = $r->variable("remote_addr");
            my $request_length = $r->variable("request_length");
            return "$pid-$msec-$remote_addr-$request_length";
          }
        }
      ';

      server {
        server_name asset-manager asset-manager.*  ;
        # Send the Strict-Transport-Security header
        add_header Strict-Transport-Security $sts_default;

        add_header Permissions-Policy interest-cohort=();

        listen {{ .Values.nginxPort }};

        proxy_set_header Host $http_host;

        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-Server $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header GOVUK-Request-Id $govuk_request_id;
        proxy_redirect off;
        proxy_connect_timeout 1s;
        proxy_read_timeout 60;

        access_log /dev/stderr timed_combined;
        access_log /dev/stdout json_event;
        error_log /dev/stderr;

        location / {
          try_files $uri/index.html $uri.html $uri @app;
        }

        location @app {
          proxy_pass http://{{ .Release.Name }};
        }

        client_max_body_size 500m;

        # Store values from Rails response headers for use in the
        # cloud-storage-proxy location block below.
        set $etag_from_rails $upstream_http_etag;
        set $last_modified_from_rails $upstream_http_last_modified;
        set $x_frame_options_from_rails $upstream_http_x_frame_options;
        set $link_from_rails $upstream_http_link;

        # For public assets requests, the Rails app will respond with the
        # X-Accel-Redirect header set to a path prefixed with
        # /cloud-storage-proxy/. This triggers an Nginx internal redirect
        # to that path which is then handled by this location block.
        location ~ /cloud-storage-proxy/(.*) {
          # Prevent requests to this location from outside Nginx
          internal;

          # Construct download URL from:
          # $1:       Host + path from regexp match in location
          # $is_args: Optional ? delimiter
          # $args:    Optional querystring params
          set $download_url $1$is_args$args;

          # The X-Accel-Redirect header contains a signed URL, $download_url, for
          # the asset on S3. The signature of this URL is based in part on the
          # request headers set in the asset-manager Rails app at the time the URL
          # is generated. The headers we send now must match otherwise Nginx will
          # not be allowed to make the request. Since this location block inherits
          # `proxy_set_header` directives from previous levels[1], we explicitly
          # set the Host so that the inherited headers are over-written.
          #
          # [1] http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header
          proxy_set_header Host $proxy_host;

          # Set response headers in the proxied response based on values stored
          # from the Rails response headers. This is so that the Rails app can
          # remain the canonical source of response headers, even though we are
          # proxying the request to S3. This is particularly relevant in the case
          # of ETag & Last-Modified, because we want keep these the same as when
          # Nginx serves the files from NFS to avoid unnecessary cache
          # invalidation. Note that Cache-Control, Content-Disposition and Content-Type
          # headers are copied from the Rails response into the proxied response by
          # default, so we do not have to do that explicitly here.
          add_header ETag $etag_from_rails;
          add_header Last-Modified $last_modified_from_rails;
          # Respect the optional Link header set by the Rails application,
          # this optional header refers to the asset's owning document.
          add_header Link $link_from_rails;


          # Additionally, we always prohibit passing on these headers from S3 to
          # the client as they are very likely to be wrong. There appears to be
          # a race condition or similar in Nginx that allows the S3 headers to
          # overwrite those set here or by Rails, possibly depending on the order
          # in which S3 sends them.
          proxy_hide_header ETag;
          proxy_hide_header Last-Modified;
          proxy_hide_header Content-Type;
          proxy_hide_header Content-Disposition;
          proxy_hide_header Cache-Control;

          # Control whether the asset can be embedded in other pages[1] by
          # respecting X-Frame-Options from the Rails application.
          # [1]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
          add_header X-Frame-Options $x_frame_options_from_rails;

          # Remove S3 HTTP headers including those listed in:
          # http://docs.aws.amazon.com/AmazonS3/latest/API/RESTCommonResponseHeaders.html
          # This keeps this HTTP response as similar as possible to the response
          # sent when using Sendfile to serve files from NFS
          proxy_hide_header x-amz-delete-marker;
          proxy_hide_header x-amz-id-2;
          proxy_hide_header x-amz-request-id;
          proxy_hide_header x-amz-version-id;
          proxy_hide_header x-amz-replication-status;
          proxy_hide_header x-amz-meta-md5-hexdigest;

          # Strip any Authorization header from the client, as this will cause
          # S3 to return an error.  We do not use proxy_hide_header here, as
          # that hides response headers sent FROM S3 to the client; whereas we
          # want to unset a request header sent TO S3 by nginx.
          proxy_set_header Authorization "";

          # Add CloudFlare and Google DNS server to avoid "no resolver defined to resolve"
          # errors when trying to connect to S3.
          resolver 1.1.1.1 8.8.8.8 8.8.4.4;

          # Download the file and send it to client
          proxy_pass $download_url;
        }

        # Endpoint for liveness and readiness checks of the nginx container.
        location = /readyz {
          return 200 'ok\n';
        }
      }
    }
